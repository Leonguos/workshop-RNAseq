---
title: "Data Preprocessing"
subtitle: "Workshop on RNA-Seq"
author: "`r paste0('<b>NBIS</b> | ',format(Sys.time(), '%d-%b-%Y'))`"
institute: NBIS, SciLifeLab
keywords: bioinformatics, course, scilifelab, nbis
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
    include: NULL
---
exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r,include=FALSE}
# load the packages you need
library(dplyr)
library(tidyr)
#library(stringr)
library(ggplot2)
#library(plotly)
library(pheatmap)
library(DESeq2)
library(edgeR)
library(gridExtra)
```

---
name: raw

## Raw data

- Raw count table

```{r,eval=TRUE,echo=FALSE}
cr <- read.table("./data/counts_raw.txt",header=TRUE)
cr[1:6,1:6]
```

- Metadata

```{r,eval=TRUE,echo=FALSE}
mr <- read.csv2("./data/metadata_raw.csv",header=TRUE,stringsAsFactors=F)
rownames(mr) <- mr$Sample_ID
mr[1:6,]
```

???

A glimpse into the count table and metadata table. It is important to make sure before any analyses that the count column names match the metadata row names perfectly. Make sure the column in both tables are of the correct data type; ie; numbers are numeric and groups are factors.

---
name: pp

## Preprocessing

- Remove genes and samples with low counts

```{r,echo=TRUE}
cf1 <- cr[rowSums(cr>0) >= 2, ]
cf2 <- cr[rowSums(cr>5) >= 2, ]
cf3 <- cr[rowSums(edgeR::cpm(cr)>1) >= 2, ]
```

- Inspect distribution

```{r,fig.height=2.7,fig.width=9,echo=FALSE}
h0 <- cr %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="Raw")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h1 <- cf1 %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="Method 1")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h2 <- cf2 %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="Method 2")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h3 <- cf3 %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="Method 3")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

gridExtra::grid.arrange(h0,h1,h2,h3,nrow=1,ncol=4)
```

- Inspect the number of rows (genes)

```{r,eval=TRUE,echo=FALSE}
cat(paste0("Raw: ",nrow(cr),", Method 1: ",nrow(cf1),", Method 2: ",nrow(cf2),", Method 3: ",nrow(cf3)))
cf <- cf3
rm(cf1,cf2,cf3)
```

???

Lowly expressed genes are removed to improve the signal-to-noise ratio. Genes not expressed in any sample can be removed completely as as they negatively affect multiple testing correction. The stringency of low count filtering can be adjusted based on the researcher's preference. It is a tradeoff between data quality vs data size.

In the above example, raw data has a huge number of zeros and the distribution of over higher value counts are barely visible. Three different levels of low count filtering are shown.

In method 1, the detection limit is set at 1 count, ie; any value above 0 is considered as an expressed gene. And we aim to have expression in atleast 2 samples.

In method 2, the detection limit is set at 5 counts, ie; any value above 5 is considered an expressed gene. A value below 5 is considered noise and is disregarded. And we aim to have 5 count expression in atleast 2 samples. Note that changing the minimum limit of detection has a dramatic effect on the count distribution. Notice how many rows (genes) are discarded.

In method 3, the limit of detection is a bit less subjective. A count that is greater than 1 count per million reads is considered a positive detection. This is the most stringent method at the expense of losing the most number of genes.

---
name: norm-1

## Normalisation

.pull-left-50[
- Make counts comparable across samples
- Control for sequencing depth

![](data/normalization_methods_depth.png)

```{r,echo=FALSE}
dfr <- data.frame(A=c(20,25,15),B=c(6,6,4))
rownames(dfr) <- c("x","y","z")
dfr$A_tc <- round(dfr$A/sum(dfr$s1),2)
dfr$B_tc <- round(dfr$B/sum(dfr$s2),2)
dfr
```
]

???

Normalisation of raw count data is necessary to make samples comparable. The comparison may be within sample, within groups, between groups and possibly between studies.

**Total count normalisation**

Imagine two samples A and B with three genes x, y and z. A has higher counts than B. Are the genes highly expressed in A? Probably not. A was sequenced deeper which resulted in more reads overall. Controlling for sequencing depth is one of the the first steps with normalisation. Total count normalisation controls for sequencing depth. See columns A_tc and B_tc for the count values after total count normalisation. If the total number of starting mRNA is comparable between samples, then this value reflects absolute expression for each gene.

Quantile normalisation, Upper quartile normalisation and Median normalisation all work in a similar way. Rather than the total count, a high quantile value or the median is used.

--

.pull-right-50[
- Control for compositional bias
![](data/normalization_methods_composition.png)

```{r,echo=FALSE}
dfr <- data.frame(A=c(0,25,15,100),B=c(20,25,4,2))
rownames(dfr) <- c("x","y","z","de")
dfr$A_tc <- round(dfr$A/sum(dfr$s1),2)
dfr$B_tc <- round(dfr$B/sum(dfr$s2),2)
dfr
#dfr$s3_tc <- round(dfr$s3/sum(dfr$s3),2)
#sf <- apply(dfr[,1:3]/(apply(dfr[,1:3],1,mean)),2,median)
#cb <- round(t(t(dfr[,1:3])/sf),2); colnames(cb) <- c("s1_c","s2_c","s3_c")
#cbind(dfr,cb)
```
]

???

**Controlling for compositional bias**

In another scenario, imagine the same two samples and four genes x,y,z and de. This time, both samples are sequenced to the same depth and the gene de is highly overexpressed in A than in B. Now, look at the total count normalised value for gene y. They have different normalised values in A and B although A and B had identical expression for gene y. This effect of few highly overexpressed genes seemingly changing the relative expression of other genes is called compositional bias.

---
name: norm-2

## Normalisation

- Make counts comparable across features (genes)
.size-60[![](data/normalization_methods_length.png)]

```{r,echo=FALSE}
dfr <- data.frame(counts=c(50,25),gene_length=c(10,5))
dfr$norm_counts <- round(dfr$counts/dfr$gene_length,2)
rownames(dfr) <- c("x","y")
dfr
```

--

- Bring counts to a human-friendly scale

???

**Controlling for gene length**

For two genes X and Y within a sample A, the longer gene will produce more reads than the shorter gene. For comparing expression of these two genes to each other, they need to be controlled for gene length.

In this example, gene x has higher counts than y. But when controlled for gene length, they both have the same expression.

**Counts per million reads**

The last point with normalisation is to bring the numbers to a human friendly scale. This the reason for the per million part of CPM, RPKM etc. 

---
name: norm-3a

## Normalisation

**Normalisation by library size**

- Assumes total expression is the same under different experimental conditions
- Methods include TC, RPKM, FPKM, TPM
- RPKM, FPKM and TPM control for sequencing depth and gene length
- TPM enables better comparison between samples and between experiments

**Normalisation by distribution**

- Assumes technical effects are same for DE and non-DE genes
- Assumes number of over and under-expressed genes are roughly same across conditions
- Corrects for compositional bias
- Methods include Q, UQ, M, RLE, TMM, MRN
- `edgeR::calcNormFactors()` implements TMM, TMMwzp, RLE & UQ
- `DESeq2::estimateSizeFactors()` implements median ratio method (RLE)
- Does not correct for gene length
- **[geTMM](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2246-7)** is gene length corrected TMM

.citation[
.cite[<i class="fas fa-link"></i> Evans, Ciaran, Johanna Hardin, and Daniel M. Stoebel. "Selecting between-sample RNA-Seq normalization methods from the perspective of their assumptions." [Briefings in bioinformatics (2017)](https://arxiv.org/abs/1609.00959)]  
]

???

Normalisation strategies can be roughly grouped into four approaches: Normalisation by library size, normalisation by distribution, normalisation by testing and normalisation using controls.

Normalisation by library size is the most basic. TPM is probably the only method that must be used. Normalisation by distribution controls for composition bias. Most software use a mix of different approaches.

---
name: norm-3b

## Normalisation

**Normalisation by testing**

- A more robust version of normalisation by distribution.
- A set of non-DE genes are detected through hypothesis testing
- Tolerates a larger difference in number of over and under expressed genes between conditions
- Methods include PoissonSeq, DEGES

**Normalisation using Controls**

- Assumes controls are not affected by experimental condition and technical effects are similar to all other genes
- Useful in conditions with global shift in expression
- Controls could be house-keeping genes or spike-ins
- Methods include RUV, CLS

**Stabilizing variance**
- Variance is stabilised across the range of mean values
- Mwthods include VST, RLOG, VOOM
- For use in exploratory analyses. Not for DE.
- `vst()` and `rlog()` functions from *DESeq2*
- `voom()` function from *Limma* converts data to normal distribution

---
name: norm-4

## Normalisation

**Recommendations**

- Most tools use a mix of many different normalisations
- For DGE using DGE R packages (DESeq2, edgeR, Limma etc), use raw counts
- For visualisation (PCA, clustering, heatmaps etc), use VST or RLOG
- For own analysis with gene length correction, use TPM (maybe geTMM?)
- Custom solutions: spike-ins/house-keeping genes

--

```{r,include=FALSE}
tpm <- function(counts,len) {
  x <- counts/len
  return(t(t(x)*1e6/colSums(x)))
}

#tpm
g <- read.delim("./data/human_genes.txt",header=T,stringsAsFactors=F)
g <- g[!duplicated(g$ensembl_gene_id),]
g$len <- g$end_position-g$start_position
rownames(g) <- g$ensembl_gene_id
igenes <- intersect(rownames(cf),g$ensembl_gene_id)
g1 <- g[igenes,]
cf1 <- cf[igenes,]
ct <- tpm(cf1,g1$len)

# deseq2
mr$Time <- factor(mr$Time)
d <- DESeqDataSetFromMatrix(countData=cf,colData=mr,design=~Time)
d <- DESeq2::estimateSizeFactors(d,type="ratio")
cd <- counts(d,normalized=TRUE)

# vst
mr$Time <- factor(mr$Time)
d <- DESeqDataSetFromMatrix(countData=cf,colData=mr,design=~Time)
d <- DESeq2::estimateSizeFactors(d,type="ratio")
d <- DESeq2::estimateDispersions(d)
cv <- as.data.frame(assay(varianceStabilizingTransformation(d,blind=T)),check.names=F)
```

```{r,fig.height=1.8,fig.width=8,echo=FALSE}
h0 <- cf %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="Raw")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h1 <- as.data.frame(edgeR::cpm(cf)) %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="CPM")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h2 <- as.data.frame(ct) %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="TPM")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h3 <- as.data.frame(cd) %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=log10(value+1),group=sample))+
  geom_density()+
  labs(x=expression('Log'[10]~'Read counts'),y="Density",title="DESeq2")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

h4 <- cv %>%
  mutate(gene=rownames(.)) %>%
  gather(key="sample",value="value",-gene) %>%
  ggplot(aes(x=value,group=sample))+
  geom_density()+
  labs(x='Read counts',y="Density",title="VST")+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())

gridExtra::grid.arrange(h0,h1,h2,h3,h4,nrow=1,ncol=5)
```

```{r,fig.height=1.8,fig.width=8,echo=FALSE}
h0 <- cf %>%
    mutate(gene=rownames(.)) %>%
    gather(key="sample",value="value",-gene) %>%
    group_by(gene) %>% summarise(mean=mean(value),var=var(value)) %>%
    ggplot(aes(x=log10(mean+1),y=log10(var+1)))+
    geom_point(alpha=0.3)+
    labs(x=expression('Log'[10]~'mean'),y=expression('Log'[10]~'variance'),title="Raw")+
    theme_bw()+
    theme(panel.border=element_blank(),
          axis.ticks=element_blank())

h1 <- as.data.frame(edgeR::cpm(cf)) %>%
    mutate(gene=rownames(.)) %>%
    gather(key="sample",value="value",-gene) %>%
    group_by(gene) %>% summarise(mean=mean(value),var=var(value)) %>%
    ggplot(aes(x=log10(mean+1),y=log10(var+1)))+
    geom_point(alpha=0.3)+
    labs(x=expression('Log'[10]~'mean'),y=expression('Log'[10]~'variance'),title="CPM")+
    theme_bw()+
    theme(panel.border=element_blank(),
          axis.ticks=element_blank())

h2 <- as.data.frame(ct) %>%
    mutate(gene=rownames(.)) %>%
    gather(key="sample",value="value",-gene) %>%
    group_by(gene) %>% summarise(mean=mean(value),var=var(value)) %>%
    ggplot(aes(x=log10(mean+1),y=log10(var+1)))+
    geom_point(alpha=0.3)+
    labs(x=expression('Log'[10]~'mean'),y=expression('Log'[10]~'variance'),title="TPM")+
    theme_bw()+
    theme(panel.border=element_blank(),
          axis.ticks=element_blank())

h3 <- as.data.frame(cd) %>%
    mutate(gene=rownames(.)) %>%
    gather(key="sample",value="value",-gene)%>%
    group_by(gene) %>% summarise(mean=mean(value),var=var(value)) %>%
    ggplot(aes(x=log10(mean+1),y=log10(var+1)))+
    geom_point(alpha=0.3)+
    labs(x=expression('Log'[10]~'mean'),y=expression('Log'[10]~'variance'),title="DESeq2")+
    theme_bw()+
    theme(panel.border=element_blank(),
          axis.ticks=element_blank())

h4 <- cv %>%
    mutate(gene=rownames(.)) %>%
    gather(key="sample",value="value",-gene) %>%
    group_by(gene) %>% summarise(mean=mean(value),var=var(value)) %>%
    ggplot(aes(x=mean,y=var))+
    geom_point(alpha=0.3)+
    labs(x='Mean',y='Variance',title="VST")+
    theme_bw()+
    theme(panel.border=element_blank(),
          axis.ticks=element_blank())

gridExtra::grid.arrange(h0,h1,h2,h3,h4,nrow=1,ncol=5)
```

.citation[
.cite[<i class="fas fa-link"></i> Dillies, Marie-Agnes, *et al*. "A comprehensive evaluation of normalization methods for Illumina high-throughput RNA sequencing data analysis." [Briefings in bioinformatics 14.6 (2013): 671-683](https://www.ncbi.nlm.nih.gov/pubmed/22988256)]
]

---
name: eda-cor

## Exploratory | Correlation

- Correlation between samples

```{r,ech=FALSE,fig.height=4.5,fig.width=5.5}
dmat <- as.matrix(cor(cv,method="spearman"))
pheatmap::pheatmap(dmat,border_color=NA,annotation_col=mr[,"Time",drop=F],
         annotation_row=mr[,"Time",drop=F],annotation_legend=T)
```

---
name: eda-dist

## Exploratory | Distance

- Similarity between samples

```{r,echo=TRUE,fig.height=4.5,fig.width=5.5}
dmat <- as.matrix(dist(t(cv)))
pheatmap(dmat,border_color=NA,annotation_col=mr[,"Time",drop=F],
         annotation_row=mr[,"Time",drop=F],annotation_legend=T)
```

---
name: eda-pca

## Exploratory | PCA

- Relationship between samples

.pull-left-40[
```{r,echo=FALSE,fig.height=3.5,fig.width=3.5}
pcaobj <- prcomp(x=t(cv))
{par(mar=c(4,4,0.5,0))
barplot(round(pcaobj$sdev^2/sum(pcaobj$sdev^2)*100,2),las=2,
        names.arg=colnames(pcaobj$x),ylab="% Variance explained",
        xlab="PCA principal components")}
```
]

.pull-right-60[
```{r,echo=FALSE,fig.height=4,fig.width=4.5}
pcamat1 <- as.data.frame(pcaobj$x)
pcamat2 <- merge(pcamat1,mr,by=0)

ggplot(pcamat2,aes(PC1,PC2,colour=Time))+
  geom_point()+
  theme_bw()+
  theme(panel.border=element_blank(),
        axis.ticks=element_blank())
```

```{r,eval=FALSE,include=FALSE}
# plotly pca
library(plotly)
pcamat2$tt <- paste0("<b>ID: </b>",pcamat2$Sample_ID,"\n",
                   "<b>Name: </b>",pcamat2$Sample_Name)
p1 <- plot_ly(pcamat2,x=~PC1,y=~PC2,z=~PC3,text=~tt,hoverinfo="text")
add_markers(p1,color=~Time)
```

]

---

# Acknowledgements

- [Normalising RNA-seq data](https://www.ebi.ac.uk/sites/ebi.ac.uk/files/content.ebi.ac.uk/materials/2012/121029_HTS/ernest_turro_normalising_rna-seq_data.pdf) by Ernest Turro  
- RNA-seq analysis [Bioconductor vignette](http://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html)

---
name: end_slide
class: end-slide, middle
count: false

# Thank you. Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
rmarkdown::render("slide_preprocessing.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_dge.html",output="presentation_dge.pdf")
```
